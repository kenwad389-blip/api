<!doctype html>
<html>
<head>
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>スケジュール管理</title>
    <!-- jQuery読み込み -->
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <!-- axios読み込み -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <!-- apiキー読み込み -->
    <script type="text/javascript" src="js/config.js"></script>
    <!-- CSS読み込み -->
    <link rel="stylesheet" href="css/style.css" />
</head>
<body>
<header>
    <h1>AIスケジュール登録</h1>
</header>
<main>
    <!-- 予定入力 -->
    <div class="input-group">
        <textarea id="userInput" placeholder="日付、時間、場所、イベント名を必ず含めて入力！"></textarea>
        <div id="historyContainer">
            <span>履歴: </span>
            <div id="historyList"></div>
            <button id="clearHistoryBtn">クリア</button>
        </div>
        <button id="addBtn">予定を追加</button>
        <p id="loadingMsg" class="loading">AIが解析中 & 保存中...</p>
    </div>

    <!-- 表示期間フィルター -->
    <div class="filter-group">
        <label>表示期間:</label>
        <input type="date" id="filterStartDate">
        <span>～</span>
        <input type="date" id="filterEndDate">
        <button id="resetFilterBtn">今日から1週間を表示</button>
    </div>

    <!-- 予定リスト -->
    <h2>予定リスト <span id="scheduleCount"></span></h2>
    <div id="scheduleList"></div>

    <!-- 編集用モーダル -->
    <div id="editModal">
        <div class="modal-content">
            <h3>予定の編集</h3>
            <label>タイトル</label> <input type="text" id="editTitle">
            <label>日付</label> <input type="date" id="editDate">
            <label>時間</label> <input type="time" id="editTime">
            <label>場所</label> <textarea id="editDescription" rows="3"></textarea>
            
            <div class="modal-actions">
                <button id="cancelEditBtn" class="cancel-btn">キャンセル</button>
                <button id="saveEditBtn" class="save-btn">保存する</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getDatabase, ref, push, onValue, update, remove } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";
        import { GoogleGenAI } from "https://esm.run/@google/genai";

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const genAI = new GoogleGenAI({ apiKey: GEMINI_API_KEY });
        
        const userInput = document.getElementById('userInput');	// 予定入力文字列
        const addBtn = document.getElementById('addBtn');	// 予定を追加するボタン
        const scheduleList = document.getElementById('scheduleList');	// 予定リスト
        const loadingMsg = document.getElementById('loadingMsg');	// 入力された文字列の解析中メッセージ
        const filterStartDate = document.getElementById('filterStartDate');	// 日付フィルターの期間開始日
        const filterEndDate = document.getElementById('filterEndDate');	// 日付フィルターの期間終了日
        const resetFilterBtn = document.getElementById('resetFilterBtn');	// 今日から1週間の表示にリセットするボタン
        const scheduleCount = document.getElementById('scheduleCount');	// 予定リストの件数
        const historyList = document.getElementById('historyList');	// localStorageに保存された予定入力履歴
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');	// localStorageに保存された履歴をクリアするボタン
        const HISTORY_KEY = 'scheduler_input_history'; // localStorageのキー

        const editModal = document.getElementById('editModal');	// 編集用モーダル
        const editTitle = document.getElementById('editTitle');	// 編集用モーダル内の「タイトル」
        const editDate = document.getElementById('editDate');	// 編集用モーダル内の「日付」
        const editTime = document.getElementById('editTime');	// 編集用モーダル内の「時間」
        const editDescription = document.getElementById('editDescription');	// 編集用モーダル内の「場所」
        const saveEditBtn = document.getElementById('saveEditBtn');	// 編集用モーダル内の「保存ボタン」
        const cancelEditBtn = document.getElementById('cancelEditBtn');	// 編集用モーダル内の「キャンセルボタン」


        let currentEditId = null;	// 編集中のリストIDを保持する変数
        let allSchedulesData = []; // 全データを保持する配列

        // *** 今日から1週間を表示期間に設定する関数 ***
        function setNextOneWeekRange() {
            const today = new Date();
            const nextWeek = new Date();
            nextWeek.setDate(today.getDate() + 7); // 今日から7日後の日付

	    // *** 日付をYYYY-MM-DD形式に変換する ***
            const formatDate = (date) => date.toISOString().split('T')[0];

            filterStartDate.value = formatDate(today);
            filterEndDate.value = formatDate(nextWeek);
        }

        // *** 期間の初期表示 ***
        setNextOneWeekRange();

        // *** localStorageから履歴を取得して表示する関数 ***
        function renderHistory() {
            const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
            historyList.innerHTML = '';

            history.forEach(text => {
                const chip = document.createElement('span');
                chip.className = 'history-chip';
                chip.textContent = text.length > 15 ? text.substring(0, 15) + '...' : text;	// 長すぎる場合は省略表示
                chip.title = text; // マウスホバーで全文表示
                
                chip.onclick = () => {	// クリックしたらテキストエリアに入力
                    userInput.value = text;
                };
                historyList.appendChild(chip);
            });
        }

        // *** localStorageに履歴を保存する関数 ***
        function saveHistory(text) {
            let history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
            history = history.filter(h => h !== text);	// 重複があれば削除（最新を先頭にするため）
            history.unshift(text);	// 先頭に追加

            if (history.length > 5) {	// 最大5件まで保持
                history = history.slice(0, 5);
            }

            localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
            renderHistory();
        }

        // *** 履歴クリアボタンが押されたとき ***
        clearHistoryBtn.addEventListener('click', () => {
            if(confirm('入力履歴をすべて削除しますか？')) {
                localStorage.removeItem(HISTORY_KEY);
                renderHistory();
            }
        });

        // *** 初回読み込み時に履歴を表示 ***
        renderHistory();

        // *** 入力文字列のAI解析（非同期関数） ***
        async function parseTextToSchedule(text) {
            const today = new Date().toISOString().split('T')[0];
            
            const prompt = `
                今日の日付: ${today}
                以下のユーザー入力からスケジュール情報を抽出してください。
                ユーザー入力: "${text}"
            `;

            try {
                const result = await genAI.models.generateContent({ // AIに質問を投げる
                    model: "gemini-2.5-flash",
                    contents: [
                        {
                            parts: [
                                { text: prompt }
                            ]
                        }
                    ],
                    config: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                title: { type: "STRING", description: "イベント名" },
                                date: { type: "STRING", description: "YYYY-MM-DD形式の日付" },
                                time: { type: "STRING", description: "HH:mm形式の時間。なければ空文字" },
                                description: { type: "STRING", description: "場所。なければ空文字" }
                            },
                            required: ["title", "date", "time", "description"]
                        }
                    }
                });

                const jsonText = result.text;
                
                if (!jsonText) return null;
                return JSON.parse(jsonText);

            } catch (error) {
                console.error("AI解析エラー:", error);
                alert("AIエラー: " + error.message);
                return null;
            }
        }

        // *** 追加ボタンが押されたとき ***
        addBtn.addEventListener('click', async () => {
            const text = userInput.value;
            if (!text) return;	// 文字が入っていなければ何もしない

            loadingMsg.style.display = 'block';	// 編集用モーダルをブロック要素で表示
            addBtn.disabled = true;

	    // *** 入力文字列のAI解析を開始 ***
            const scheduleData = await parseTextToSchedule(text);

            if (scheduleData) {
                if (!scheduleData.title || !scheduleData.date || !scheduleData.time || !scheduleData.description) { // タイトル、日付、時間、場所のいずれか抜き出せない場合は何もしない
                    alert("【登録エラー】\n必要な情報が不足しています。\nより具体的に入力してください。");
                    loadingMsg.style.display = 'none';	// 編集用モーダルを表示しない
                    addBtn.disabled = false;
                    return; 
                }

                try {
                    const dbRef = ref(db, 'schedules');
                    await push(dbRef, {	// データベースに保存
                        ...scheduleData,
                        createdAt: new Date().toISOString()
                    });

                    saveHistory(text);	// 保存成功時に履歴にも追加
                    userInput.value = "";	// 入力欄をクリア
                } catch (e) {
                    console.error(e);
                    alert("保存エラー: データベース接続を確認してください");
                }
            } else {
                alert("AI解析失敗。再試行してください。");
            }

            loadingMsg.style.display = 'none';	// 編集用モーダルを表示しない
            addBtn.disabled = false;
        });

        const schedulesRef = ref(db, 'schedules');	// リスト取得用

        // *** データが変更したら全データを取得する ***
        onValue(schedulesRef, (snapshot) => {
            const data = snapshot.val();
            if (!data) {	// データがなければ何もしない
                allSchedulesData = [];
                renderScheduleList();
                return;
            }

            // *** オブジェクトを配列に変換 ***
            allSchedulesData = Object.entries(data).map(([key, value]) => {
                return { id: key, ...value };
            });

            // *** 日付順 → 時間順にソート ***
            allSchedulesData.sort((a, b) => {
                const dateDiff = new Date(a.date) - new Date(b.date);
                if (dateDiff !== 0) return dateDiff;
                if ((a.time || "") < (b.time || "")) return -1;
                if ((a.time || "") > (b.time || "")) return 1;
                return 0;
            });

            // *** リストを画面表示 ***
            renderScheduleList();
        });

        // *** リストを画面に表示する関数 (フィルター適用) ***
        function renderScheduleList() {
            scheduleList.innerHTML = "";
            
            const startStr = filterStartDate.value;
            const endStr = filterEndDate.value;

            // *** 期間の開始日から終了日までに該当するものを抽出 ***
            const filteredData = allSchedulesData.filter(item => {
                if (!startStr || !endStr) return true; // 期間未設定なら全表示
                return item.date >= startStr && item.date <= endStr;
            });

            scheduleCount.innerText = `(${filteredData.length}件)`;	// リストの件数

            if (filteredData.length === 0) {	// 件数がゼロの場合
                scheduleList.innerHTML = "<p>指定期間の予定はありません。</p>";
                return;
            }

            filteredData.forEach((item) => {	// リストからカードを1件ずつ作成
                const card = document.createElement('div');
                card.className = 'event-card';
                card.innerHTML = `
                    <div class="date">${item.date} ${item.time}</div>
                    <h3>${item.title}</h3>
                    <p>${item.description}</p>
                    <div class="card-actions"></div>
                `;

                const actionContainer = card.querySelector('.card-actions');

                const editButton = document.createElement('button');	// 編集ボタン
                editButton.className = 'edit-btn';
                editButton.innerText = '編集';
                editButton.onclick = () => openEditModal(item);
                
                const deleteButton = document.createElement('button');	// 削除ボタン
                deleteButton.className = 'delete-btn';
                deleteButton.innerText = '削除';

	        // *** 削除ボタンが押されたとき ***
                deleteButton.onclick = async () => {
                    if (confirm(`「${item.title}」を削除しますか？`)) {
                        try {
                            const itemRef = ref(db, 'schedules/' + item.id);
                            await remove(itemRef);
                        } catch (e) {
                            alert("削除失敗");
                        }
                    }
                };

                actionContainer.appendChild(editButton);
                actionContainer.appendChild(deleteButton);
                scheduleList.appendChild(card);
            });
        }

        // *** フィルターの日付が変わったらリストを再表示 ***
        filterStartDate.addEventListener('change', renderScheduleList);
        filterEndDate.addEventListener('change', renderScheduleList);

        // *** 1週間を表示するボタンが押されたらフィルターの日付を更新してリストを再表示 ***
        resetFilterBtn.addEventListener('click', () => {
            setNextOneWeekRange();
            renderScheduleList();
        });

        // *** 編集用モーダルが呼び出されたとき ***
        function openEditModal(item) {
            currentEditId = item.id;
            editTitle.value = item.title || "";
            editDate.value = item.date || "";
            editTime.value = item.time || "";
            editDescription.value = item.description || "";
            editModal.style.display = 'flex';	// 編集用モーダルを表示
        }

        // *** 編集のキャンセルボタンが押されたとき ***
        cancelEditBtn.addEventListener('click', () => {
            editModal.style.display = 'none';
            currentEditId = null;
        });

        // *** 編集の保存ボタンが押されたとき ***
        saveEditBtn.addEventListener('click', async () => {
            if (!currentEditId) return;
            const itemRef = ref(db, 'schedules/' + currentEditId);
            try {
                await update(itemRef, {	// 上書き保存
                    title: editTitle.value,
                    date: editDate.value,
                    time: editTime.value,
                    description: editDescription.value
                });
                editModal.style.display = 'none';
                currentEditId = null;
            } catch (e) {
                alert("更新失敗");
            }
        });

    </script>
</main>
</body>
</html>